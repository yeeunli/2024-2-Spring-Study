# 2024-2-Backend-Study

2024년 2학기에 진행되는 스프링으로 진행되는 백엔드 스터디 커리큘럼 과제 제출입니다.

---

## 🎈 오늘은 뭘 배워볼까? 🎈

👩‍🏫 JPA로 레포지토리 계층에서 실제 데이터를 조작해보자❕

---

### 다시 한 번 짚고 가자

**ERD**로 DB 구조를 설계하고,

**JPA**로 자바 객체 즉, **엔티티**와 DB를 이어주자

### 레포지토리와 DB는 어떻게 소통할까?

**레포지토리 계층**

- DB와 소통하며 데이터 조작 (CRUD)

- 서비스 계층이 결정한 비즈니스 로직을 DB에 적용

#### 데이터 조작을 어떻게 하나?

> JPA가 제공하는 기능을 이용

- Entity Manager

  - 즉, 엔티티를 관리해주는 아이

  - db와 직접 소통하는 객체

  - 엔티티 객체에 대한 CRUD 기능 수행

- 트랜잭션

  - ~~DB와 마찬가지로,~~ JPA 또한 트랜잭션이 기본 동작 단위
  - 여러 동작을 하나로 묶어서 all or nothing 즉, **atomic**하게 동작

    (따라서, 트랜잭션 중간에 에러 발생 시, 트랜잭션 범위 안의 모든 변경점을 되돌림; 롤백)

- 영속성 컨텍스트

  - DB에서 조회한 엔티티를 **캐싱**(_임시 보관_)하는 공간
  - JPA가 DB에 반영할 엔티티의 모든 변경 사항을 **보관**하는 공간

    (∵ DB에 여러번 접근하지 않고, 모든 변경 사항을 영속성 컨텍스트에 잠시 보관해두고 한 번에 반영하면 효율적이니)

### 엔티티를 다루어보자

#### 1. 엔티티 저장

- em.persist()

  - 영속성 컨텍스트에 엔티티 등록해줘~ 할 때

  - 객체를 생성해두기만한 **비영속 상태**에서 엔티티를 영속성 컨텍스트에 넣어서 **영속 상태**로 전환

  - `insert query`

- em.flush()

  - 트랜잭션이 끝난 후,

    영속성 컨텍스트에 있던 모든 변경 사항 DB에 반영해줘~ 할 때

#### 2. 엔티티 조회

- em.find()

  - `select query`

  - DB에서 읽어온 데이터로 엔티티 객체를 만들어 영속성 컨텍스트에 저장

  - 한 번 조회한 정보는 1차 캐시(임시 저장)하여 나중에 또 조회하고 싶을 때, DB 접근 없이 조회 (→ 동일 객체 보장)

#### 3. 엔티티 수정

- em.find()

  - `select query`

  - 수정할 데이터를 DB에서 가져와서 엔티티 객체를 만들어 영속성 컨텍스트에 저장

- 변경 감지

  - 컨텍스트 안에 있는 객체를 우리가 수정해두면,

    엔티티 매니저가 수정된 정보와 최초 상태를 비교해서 SQL 생성

- em.flush()

  - `update query`

  - 트랜잭션이 끝나면 알아서 변경된 정보가 한 번에 DB에 반영됨; 쓰기 지연

#### 4. 엔티티 삭제

- em.find()

  - `select query`

  - 삭제할 데이터를 DB에서 가져와서 엔티티 객체를 만들어 영속성 컨텍스트에 저장

- em.remove()

  - 컨텍스트 안에 있는 객체를 우리가 삭제해두면,

    엔티티 매니저가 엔티티를 삭제 상태로 변경

- em.flush()

  - `delete query`

  - 트랜잭션이 끝나면 알아서 영속성 컨텍스트에 기록된 변경된 정보(삭제할 내용)가 한 번에 DB에 반영됨; 쓰기 지연

---

## 이번 주차를 공부한 뒤 느낀점은❔

🧸: 이론 설명이 이번 주차는 잘 와닿아서 다행이었다. 예전에 기초데이터베이스 수업에서 배웠던 개념들이 이번 주차에 도움이 되어서 이해가 수월했다. 트랜잭션과 원자성 등의 개념을 다시 상기하니 예전에는 막연했던 내용이 이번에는 보다 명확하게 다가왔다. 휴~
